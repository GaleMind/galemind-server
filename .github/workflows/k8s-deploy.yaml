name: Kubernetes deployment

on:
  # upon successful workflow on main/develop branch, provided k8  ,
  # OR upong simply tagging "k8s_v*"
  workflow_run:
    workflows:
     - "Build and Push Docker Image"
    types:
      - completed

  push:
    tags:
      - 'k8s_v*'

jobs:
  check-viability:
    # just to focus on rules that trigger Kubernetes deployment
    runs-on: ubuntu-lates
    # run only if in a successful workflow_run from branches 'main' or 'develop'
    #   or in a suitable tag push
    if: (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' 
             && (contains(github.event.workflow_run.head_branch, 'refs/heads/main')
                  || contains(github.event.workflow_run.head_branch, 'refs/heads/develop') )) 
        || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/k8s_v'))
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      wf_run_id: ${{ steps.check.outputs.wf_run_id }}
      wf_branch: ${{ steps.check.outputs.wf_branch }}
    steps:
      - name: Minimal code checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Deployment request viability check
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          current_check=false
          wf_run_id=""
          wf_branch=""
          TAGS=$(git tag --points-at HEAD | grep '^k8s_v' || true) 
          # need at least a k8s_v TAG on this commit 
          if [[ -z "$TAGS" ]]; then
            echo "No k8s_v tag found on this commit... it should not trigger a K8s deployment."
          else
            if [[ "${{ github.event_name }}" == 'workflow_run' ]]; then
              # upon workflow_run
              TAGS="${{ github.event.workflow_run.head_ref }}"
              echo "Reacting to workflow_run, with tags $TAGS"              
              if [[ $TAGS =~ ^refs/tags/v.+\+k8s ]] ; then
              echo "Found tag(s): $TAGS and I've been triggered by a 'workflow_run' event... I'll try to deploy to K8s."
              current_check=true   
              wf_run_id="${{ github.event.workflow_run.id }}"
              wf_branch="${{ github.event.workflow_run.head_branch }}"
              else
                echo "No '*+k8s' tag found in [$TAGS] ... won't trigger any K8s deployment"
              fi              
            else
              # upon simple tag push 
              # check if  last Docker build run was successfull for this commit
              echo "Reacting by simple tag push... $TAGS"
              BUILD_RUN=$(gh api \
                "/repos/${{ github.repository }}/actions/runs?head_sha=${{ github.sha }}" \
                --jq '[.workflow_runs[] | select(.name == "Build and Push Docker Image")] 
                      | sort_by(.id) | .[-1]|{"id":.id, "conclusion": .conclusion, "branch":.head_branch}')         
              if [[ $(jq -r '.conclusion ' <<<"$BUILD_RUN") == "success" ]]; then
                current_check=true
                wf_run_id=$(jq -r '.id' <<<"$BUILD_RUN")
                wf_branch=$(jq -r '.branch' <<<"$BUILD_RUN")
              else
                echo "Last Docker build was not 'successful', won't try to deploy to Kubernetes"
              fi
            fi
          fi
          echo "should_deploy=$current_check" >> $GITHUB_OUTPUT
          echo "wf_run_id=$wf_run_id" >> $GITHUB_OUTPUT
          echo "wf_branch=$wf_branch" >> $GITHUB_OUTPUT


  deploy:
    runs-on: ubuntu-latest
    needs: check-viability
    steps:
      - name: No viable deploy
        run: |
          if [[ ${{ needs.check-viability.outputs.should_deploy }} != 'true' ]] ; then 
            echo "Nothing to do!"
            exit 1
          fi            


      - name: Checkout code
        uses: actions/checkout@v5

      - name: Previous workflow data via artifact download
        uses: actions/download-artifact@v4
        with:
          name: docker-build-info
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ needs.check-viability.outputs.wf_run_id }}
          # now docker_image_digest.txt contains the digest of the image
          # that was pushed by last successful docker pushing workflow on this commit

      - name: Kubectl configuration
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Helm setup
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.3'

      - name: Variable assignment and Helm value customization
        id: vars
        run: |
          # Previous successful branch name
          BRANCH_NAME="${{ needs.check-viability.outputs.wf_branch }}"
          
          # FIXME
          # Sanitizza il nome del branch per usarlo come tag (sostituisci / con -)
          IMAGE_TAG=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          
          # Choose appropriate values.yaml
          if [ "$BRANCH_NAME" == "main" ]; then
            VALUES_PATH="production"
            ENV="prod"
          elif [ "$BRANCH_NAME" == "develop" ]; then
            VALUES_PATH="dev"
            ENV="dev"
          else
            VALUES_PATH="staging"
            ENV="staging"
          fi
          
          VALUE_FILE=./infra/helm/environments/$VALUES_PATH/values.yaml

          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "value_file=$VALUE_FILE" >> $GITHUB_OUTPUT
          echo "environment=$ENV" >> $GITHUB_OUTPUT



      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Helm deployment
        run: |
          ENV=${{ steps.vars.outputs.environment }}
          # FROM artifact download
          IMAGE_DIGEST=$(cat docker_image_digest.txt)
          DOCKER_PREFIX=$(sed 's:[^a-zA-Z0-9]::g' <<<"${{ vars.DOCKER_REGISTRY }}")
          kubectl create secret docker-registry ${DOCKER_PREFIX}-secret \
            --docker-server=${{ vars.DOCKER_REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --docker-email="galemind.zen@gmail.com" \
            --namespace=galemind-$ENV || true # should it already exist, ignore the error
          helm upgrade galemind-server-$ENV ./infra/helm/galemind-server \
            --install \
            --namespace galemind-$ENV \
            --create-namespace \
            -f ${{ steps.vars.outputs.value_file }} \
            --set imagePullSecrets[0].name=${DOCKER_PREFIX}-secret \
            --set image.repository=${{ vars.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_IMAGE }} \
            --set image.tag=${{ steps.vars.outputs.image_tag }} \
            --set image.digest=$IMAGE_DIGEST \
            --atomic \
            --wait \
            --timeout 10m



      - name: Helm deployment check
        run: |
          kubectl rollout status deployment/galemind-server \
            -n galemind-${{ steps.vars.outputs.environment }} \
            --timeout=5m
