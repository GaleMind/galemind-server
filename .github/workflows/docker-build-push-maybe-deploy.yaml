name: Build and push Docker image and maybe deploy to Kubernetes

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'  # for Docker image publishing ; add "_k8s" to get Kubernetes deployment
  pull_request:
    branches:
      - main

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    # avoid building if reacting to simple tag push
    outputs:
      pushedimageid: ${{ steps.valuesharing.outputs.pushedimageid }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Check for any previous workflow run
        id: previous-wf-check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          WF_ID=$(gh api \
            "/repos/${{ github.repository }}/actions/runs?head_sha=${{ github.sha }}" \
            --jq '[.workflow_runs[] | select(.name == "'${{ github.workflow }}'")
                   | select(.conclusion=="success")] 
                   | sort_by(.id) | .[-1].id // empty')
          echo "wf_run_id=$WF_ID" >> $GITHUB_OUTPUT

      - name: Previous workflow data via artifact download
        uses: actions/download-artifact@v4
        if: steps.previous-wf-check.outputs.wf_run_id
        with:
          name: docker-build-info
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ steps.previous-wf-check.outputs.wf_run_id }}
          # from now on the file "docker_image_digest.txt" contains
          # the digest of this commit's image that was pushed to Docker repo

      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Decide whether build-and-push can be skipped
        id: check-need-to-build-and-push
        # if for this commit
        #   1. a successful build has already pushed the Docker image
        #   2. and that image is still present in the Docker repo
        # then there is no need to build&push again
        run: |
          SHOULD=true
          IMAGE_DIGEST=$(cat docker_image_digest.txt 2>/dev/null || true)
          if [[ -n "$IMAGE_DIGEST" ]] ; then
            TOKEN=$(curl -s -u "${{ secrets.DOCKER_USERNAME }}:${{ secrets.DOCKER_PASSWORD }}"\
                         "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_REPO }}:pull" \
                    | jq -r '.token')
            EXISTING=$(curl -Is -w %{http_code} -o /dev/null -H "Authorization: Bearer $TOKEN" \
                            -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                            "https://registry-1.docker.io/v2/${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_REPO }}/manifests/$IMAGE_DIGEST" )
            if [[ $EXISTING -eq 200 ]] ; then 
              SHOULD=false          
            fi
          fi
          echo "should_build_and_push=$SHOULD" >> $GITHUB_OUTPUT        

      - name: Set up Docker Buildx
        if: steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: (steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true') && (github.event_name != 'pull_request')
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        if: steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_REPO }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{version}}+k8s
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=dev,enable=${{ github.ref_name == 'develop' }}
            type=raw,value=staging,enable='false'

      - name: Build and push Docker image
        if: steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true'
        uses: docker/build-push-action@v5
        id: buildandpush
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}

      - name: Lay down my will
        if: steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true'
        id: valuesharing
        run: |
          # export artifact to external workflows
          echo "${{ steps.buildandpush.outputs.digest }}" > docker_image_digest.txt
          echo "pushedimageid=${{ steps.buildandpush.outputs.digest }}"  >> "$GITHUB_OUTPUT"

      - name: My will to posterity
        if: steps.check-need-to-build-and-push.outputs.should_build_and_push == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: docker-build-info
          path: |
            docker_image_digest.txt

      - name: Kubectl configuration
        if: ${{ endsWith(github.ref_name,'+k8s')}}
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Helm setup
        if: ${{ endsWith(github.ref_name,'+k8s')}}
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.3'

      - name: Variable assignment and Helm value customization
        if: ${{ endsWith(github.ref_name,'+k8s')}}
        id: vars
        run: |
          # Previous successful branch name
          BRANCH_NAME="${{ github.ref_name }}"
          
          # FIXME
          # Sanitize branch name to use it as a tag (replace "/" with "-")
          IMAGE_TAG=$(echo "$BRANCH_NAME" | sed 's/\//-/g')
          
          # Choose appropriate "values.yaml"
          if [ "$BRANCH_NAME" == "main" ]; then
            VALUES_PATH="production"
            ENV="prod"
          elif [ "$BRANCH_NAME" == "develop" ]; then
            VALUES_PATH="dev"
            ENV="dev"
          else
            VALUES_PATH="staging"
            ENV="staging"
          fi
          
          VALUE_FILE=./infra/helm/environments/$VALUES_PATH/values.yaml

          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "value_file=$VALUE_FILE" >> $GITHUB_OUTPUT
          echo "environment=$ENV" >> $GITHUB_OUTPUT

      - name: Helm deployment
        if: ${{ endsWith(github.ref_name,'+k8s')}}
        run: |
          ENV=${{ steps.vars.outputs.environment }}
          # FROM artifact download
          IMAGE_DIGEST=$(cat docker_image_digest.txt)
          DOCKER_PREFIX=$(sed 's:[^a-zA-Z0-9]::g' <<<"${{ vars.DOCKER_REGISTRY }}")
          kubectl create secret docker-registry ${DOCKER_PREFIX}-secret \
            --docker-server=${{ vars.DOCKER_REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --docker-email="galemind.zen@gmail.com" \
            --namespace=galemind-$ENV || true # should it already exist, ignore the error
          helm upgrade galemind-server-$ENV ./infra/helm/galemind-server \
            --install \
            --namespace galemind-$ENV \
            --create-namespace \
            -f ${{ steps.vars.outputs.value_file }} \
            --set imagePullSecrets[0].name=${DOCKER_PREFIX}-secret \
            --set image.repository=${{ vars.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_REPO }} \
            --set image.tag=${{ steps.vars.outputs.image_tag }} \
            --set image.digest=$IMAGE_DIGEST \
            --atomic \
            --wait \
            --timeout 10m

      - name: Helm deployment check
        if: ${{ endsWith(github.ref_name,'+k8s')}}
        run: |
          ENV=${{ steps.vars.outputs.environment }}
          kubectl rollout status deployment galemind-server-$ENV -n galemind-$ENV --timeout=5m

  security-scan:
    runs-on: ubuntu-latest
    needs: build-push-deploy
    if: ${{ (github.event_name != 'pull_request') && (needs.build-push-deploy.outputs.pushedimageid != '' ) }}
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Log in to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        env:
          # is IMGID requested in the environment by aquasecurity/trivy-action@master ?
          IMGID: "${{ vars.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ vars.DOCKER_REPO }}@${{ needs.build-push-deploy.outputs.pushedimageid }}"
        with:
          image-ref: ${{ env.IMGID }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

